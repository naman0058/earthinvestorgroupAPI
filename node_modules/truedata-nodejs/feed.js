const WebSocket = require('ws');
const axios = require('axios');
const path = require('path');
const fs = require('fs');
const rtFeed = require('./event').rtFeed;

const utils = require('./utils');

let connection = null;
let disconnectConnection = false;
let hearbeatCheckerCalled = false;
let totalSymbolsAdded = 0;
let additionSub = false;
let additionSubLength = null;
let lastHeartBeatTime = 0;
let fullFeed = false;

let user;
let pwd;
let port;
let connectionUrl = 'wss://push.truedata.in:';
let bidaskData;
let heartbeatMessage;
let symbols = [];

const reconnectLogs = [];
const touchlineData = {};
let touchlineMap = {};

const { bidDeactivatedMessage, reconnectionTime } = utils;

module.exports.rtConnect = (
	username,
	password,
	allSymbols,
	userPort = 8082,
	bidaskFeed = 1,
	heartbeat = 1,
	replay = 0
) => {
	disconnectConnection = false;
	hearbeatCheckerCalled = false;
	if (typeof allSymbols === 'object') symbols = [...allSymbols];
	if (typeof allSymbols === 'string') symbols = [allSymbols];
	bidaskData = bidaskFeed === 1 ? true : false;
	heartbeatMessage = heartbeat === 1 ? true : false;
	if (replay === 1) connectionUrl = 'wss://replay.truedata.in:';
	user = username;
	pwd = password;
	port = userPort;
	connect();
};

module.exports.rtConnectFullFeed = async (
	username,
	password,
	symbolName = 1,
	userPort = 8082,
	bidaskFeed = 1,
	heartbeat = 1,
	replay = 0
) => {
	disconnectConnection = false;
	hearbeatCheckerCalled = false;
	fullFeed = true;

	if (symbolName !== 0) {
		const d = new Date();
		const date = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()).toDateString();
		const time = new Date().setUTCHours(2, 40, 0);

		const symbolNamePath = path.join(__dirname, 'symbolName.json');

		try {
			const symbolFile = JSON.parse(fs.readFileSync(symbolNamePath));
			if (symbolFile && symbolFile[date] && symbolName !== 2) {
				touchlineMap = symbolFile[date];
			} else throw '';
		} catch (err) {
			console.log('Downloading Symbol Names... ( To skip this, please put symbolName = 0 while connecting )');
			await fetchSymbolNames(username, password, symbolNamePath, date);
		}

		if (d < time) {
			setTimeout(async () => {
				console.log('Updating Symbol Names...');
				await fetchSymbolNames(username, password, symbolNamePath, date);
				closeConnection();
			}, time - d + 20000);
		}
	}

	bidaskData = bidaskFeed === 1 ? true : false;
	heartbeatMessage = heartbeat === 1 ? true : false;
	if (replay === 1) connectionUrl = 'wss://replay.truedata.in:';
	user = username;
	pwd = password;
	port = userPort;
	connect();
};

module.exports.rtSubscribe = (subSymbols) => {
	if (connection) {
		additionSub = true;
		additionSubLength = subSymbols.length;
		symbols = [...symbols, ...subSymbols];
		subscribe(subSymbols);
	} else {
		console.log(
			'Error: Please use rtConnect(user, pwd, symbols, port, (bidask = 0), (heartbeat = 1)) to initiate connection.'
		);
	}
};

module.exports.rtUnsubscribe = (unSubSymbols) => {
	symbols = symbols.filter((symbol) => !unSubSymbols.includes(symbol));
	unSubscribe(unSubSymbols);
};

module.exports.rtDisconnect = () => {
	if (connection) {
		disconnectConnection = true;
		for (let i = 0; i < 20; i++) {
			clearInterval(t);
		}
		closeConnection();
	} else {
		console.log('Calling rtDisconnect before the websocket connection is established');
	}
};

const connect = () => {
	console.log('Connecting..');
	url = connectionUrl + port + '?user=' + user + '&password=' + pwd;
	console.log(url);
	try {
		connection = new WebSocket(url);

		connection.onopen = socketonopen;
		connection.onerror = socketonerror;
		connection.onmessage = socketonmessage;
		connection.onclose = socketonclose;

		return true;
	} catch (error) {
		console.log(error);
		setInterval(connect, reconnectionTime);
		return false;
	}
};

function socketonopen(e) {
	console.log('Connected Websocket');
}
function socketonerror(e) {
	console.log('Websocket Error ' + e.message);
}

function socketonmessage(e) {
	var jsonObj = JSON.parse(e.data);

	if (jsonObj.trade != null) {
		const tradeArray = jsonObj.trade;
		rtFeed.emit('tick', handleRealTimeData(tradeArray));
	} else if (bidaskData && jsonObj.bidask != null) {
		const bidaskArray = jsonObj.bidask;
		rtFeed.emit('bidask', handleBidaskData(bidaskArray));
	} else if (jsonObj.bar1min) {
		const barArray = jsonObj.bar1min;
		rtFeed.emit('bar', handleBarData(barArray, '1min'));
	} else if (jsonObj.bar5min) {
		const barArray = jsonObj.bar5min;
		rtFeed.emit('bar', handleBarData(barArray, '5min'));
	} else if (jsonObj.interval) {
		const bar = jsonObj.interval;
		const barDataArray = jsonObj.data.map((barArray) => handleFullFeedBarData(barArray, bar));
		rtFeed.emit('barArray', barDataArray);
	} else if (jsonObj.success) {
		switch (jsonObj.message) {
			case 'TrueData Real Time Data Service':
				if (reconnectLogs.length === 0) console.log(jsonObj);

				if (!hearbeatCheckerCalled) {
					hearbeatChecker();
					hearbeatCheckerCalled = true;
				}
				!fullFeed && subscribe(symbols);
				break;

			case 'symbols added':
				totalSymbolsAdded += jsonObj.symbolsadded;
				console.log(
					`Added Symbols:${jsonObj.symbolsadded}, Total Symbols Subscribed:${jsonObj.totalsymbolsubscribed}`
				);

				jsonObj.symbollist.forEach((d) => {
					touchlineData[d[1]] = handleTouchline(d);
					touchlineMap[d[1]] = d[0];
				});

				if (
					jsonObj.totalsymbolsubscribed === symbols.length ||
					(additionSub && totalSymbolsAdded === additionSubLength)
				) {
					if (reconnectLogs.length === 0 || additionSub) rtFeed.emit('touchline', touchlineData);
					totalSymbolsAdded = 0;
					additionSub = false;
					additionSubLength = null;
				}
				break;

			case 'symbols removed':
				console.log(
					`Removed Symbols:${jsonObj.symbolsremoved}, Symbols Subscribed:${jsonObj.totalsymbolsubscribed}`
				);
				break;

			case 'touchline':
				jsonObj.symbollist.forEach((touchline) => {
					touchlineData[touchline[1]] = handleTouchline(touchline);
				});

				rtFeed.emit('touchline', touchlineData);
				break;

			case 'HeartBeat':
				const { message, timestamp } = jsonObj;
				heartbeatMessage && console.log('Message ' + message + ' Time: ' + timestamp);
				rtFeed.emit('heartbeat', { Message: message, Timestamp: timestamp });
				lastHeartBeatTime = Date.now();
				break;

			case 'marketstatus':
				rtFeed.emit('marketstatus', jsonObj.data);
				break;

			default:
				console.log(jsonObj);
		}
	} else if (jsonObj.success == false) {
		console.log('Not connected');
		console.log(jsonObj);
	}
}

function closeConnection() {
	connection.close();
}

function socketonclose() {
	console.log('Disconnected Websocket');
	if (!disconnectConnection) setTimeout(connect, reconnectionTime);
}

function subscribe(symbols) {
	//for-loop to override max 65000 characters
	for (let i = 0; i <= symbols.length; i += 1500) {
		const jsonRequest = {
			method: 'addsymbol',
			symbols: symbols.slice(i, i + 1500),
		};
		let s = JSON.stringify(jsonRequest);
		connection.send(s);
	}
}

function unSubscribe(symbols) {
	for (let i = 0; i <= symbols.length; i += 1500) {
		const jsonRequest = {
			method: 'removesymbol',
			symbols: symbols.slice(i, i + 1500),
		};
		let s = JSON.stringify(jsonRequest);
		connection.send(s);
	}
}

function hearbeatChecker() {
	t = setInterval(() => {
		const checkerHeartBeat = Date.now() - lastHeartBeatTime;
		if (checkerHeartBeat > 15000) {
			closeConnection();
			hearbeatCheckerCalled = false;
			const reconnectLog = `Auto Reconnect Initiated @ ${new Date().toLocaleTimeString()}`;
			reconnectLogs.push(reconnectLog);
			console.log(reconnectLog);
			for (let i = 0; i < 20; i++) {
				clearInterval(t);
			}
		}
	}, 20000);
}

function handleTouchline(touchline) {
	return {
		Symbol: touchline[0],
		LastUpdateTime: touchline[2],
		LTP: +touchline[3],
		TickVolume: +touchline[4],
		ATP: +touchline[5],
		TotalVolume: +touchline[6],
		Open: +touchline[7],
		High: +touchline[8],
		Low: +touchline[9],
		Previous_Close: +touchline[10],
		Today_OI: +touchline[11],
		Previous_Open_Interest_Close: +touchline[12],
		Turnover: +touchline[13],
		Bid: +touchline[14] || 0,
		BidQty: +touchline[15] || 0,
		Ask: +touchline[16] || 0,
		AskQty: +touchline[17] || 0,
	};
}

function handleRealTimeData(tradeArray) {
	return {
		Symbol: touchlineMap[tradeArray[0]],
		Symbol_ID: +tradeArray[0],
		Timestamp: tradeArray[1],
		LTP: +tradeArray[2],
		LTQ: +tradeArray[3],
		ATP: +tradeArray[4],
		Volume: +tradeArray[5],
		Open: +tradeArray[6],
		High: +tradeArray[7],
		Low: +tradeArray[8],
		Prev_Close: +tradeArray[9],
		OI: +tradeArray[10],
		Prev_Open_Int_Close: +tradeArray[11],
		Day_Turnover: +tradeArray[12],
		Special: tradeArray[13],
		Tick_Sequence_No: +tradeArray[14],
		Bid: tradeArray[15] !== undefined ? +tradeArray[15] : bidDeactivatedMessage,
		Bid_Qty: tradeArray[16] !== undefined ? +tradeArray[16] : bidDeactivatedMessage,
		Ask: tradeArray[17] !== undefined ? +tradeArray[17] : bidDeactivatedMessage,
		Ask_Qty: tradeArray[18] !== undefined ? +tradeArray[18] : bidDeactivatedMessage,
	};
}

function handleBidaskData(bidaskArray) {
	return {
		Symbol: touchlineMap[bidaskArray[0]],
		SymbolId: bidaskArray[0],
		Time: bidaskArray[1],
		Bid: +bidaskArray[2],
		BidQty: +bidaskArray[3],
		Ask: +bidaskArray[4],
		AskQty: +bidaskArray[5],
	};
}

function handleBarData(barArray, bar) {
	return {
		Symbol: touchlineMap[barArray[0]],
		SymbolId: barArray[0],
		Bar: bar,
		Time: barArray[1],
		Open: +barArray[2],
		High: +barArray[3],
		Low: +barArray[4],
		Close: +barArray[5],
		Volume: +barArray[6],
		OI: +barArray[7],
	};
}

function handleFullFeedBarData(barArray, bar) {
	return {
		Symbol: touchlineMap[barArray[1]],
		SymbolId: barArray[1],
		Bar: bar,
		Time: barArray[0],
		Open: +barArray[2],
		High: +barArray[3],
		Low: +barArray[4],
		Close: +barArray[5],
		Volume: +barArray[6],
		OI: +barArray[7],
	};
}

async function fetchSymbolNames(username, password, symbolNamePath, date) {
	const symbolNames = await axios
		.get(`https://api.truedata.in/getAllSymbols?segment=all&user=${username}&password=${password}&allexpiry=false`)
		.catch((err) => console.log('Downloading Symbol Names Failed...', err.response));
	symbolNames.data.Records.forEach((d) => {
		touchlineMap[d[0]] = d[1];
	});

	fs.writeFileSync(symbolNamePath, JSON.stringify({ [date]: touchlineMap }));

	return;
}